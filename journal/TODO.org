#+title: Todo

* documenting the boot process
 - [ ] what does it mean to boot into something
* how do you decide what language to use
 - [ ] when and where does assembly come into the picture
* what are some minimal features that your os should have
* live breakdown of the source of an existing operating system
 - [ ] from a user interface perspective : what are ISOs
 - [ ] how could one actually mount an ISO and get it started
 - [ ] writing a hypervisor : is that the next step to feeling competent
 - [ ] different sort of OS architectures and what they do

* what are some long term eternals for the project
        - a work oriented ideation journal for tracking qualitative progress
        - an idea connection map to maintain a context throughout the larger duration of the project
        - being able to search quickly and ask doubts
          - copy pasting, browser interop , llm clients
          - eshell, man pages, decoding hex, more
          - emacs has all sorts of extensions for anything that I need
          - If I need something, I could just write whatever I need with more ease than I would be able to in vs code or any other editor
          - supporting theory with man pages and more : textbook + man pages
          - how to use the host OS to study stuff quickly





        - ways to document todos and provide structured updates
        - top down vs bottom up at the same time
        - what sort of cadence do I need?

* enabling interface / API for the usual generic stuff : above and below the OS
 - POSIX?
 - thinking in terms of interfaces and how all the layers interact
 - getting down to the abstractions that the hardware provides and the ones that the generic software demand

* how do you handle data persistence?
* what are the problems of existing operating systems : what do you plan on doing differently? : design goals
* what are some current OS research efforts and why do those threads exist?
* what about tunable kernel space programs/operating systems as a whole
* what about having a more flexible API for operating systems : should readup on POSIX
* what about proving the correctness and fairness of your generic orchestration algorithms : how can/does one quantify it
